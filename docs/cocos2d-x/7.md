# <h1>内存管理</h1> 
# 快速导航
  * [内存基础知识](#_1内存基础知识)

# 1.内存基础知识
  ## 1.1 内存区域的划分

    - c++将程序的内存分为五个区--栈、堆、常量存储区、静态存储区和程序代码区

  ## 1.2 new 和 malloc 的区别

    - malloc 分配的内存使用 free 来释放, new 分配的内存使用 delete 来释放.
    - malloc/free 是 C/C++ 的标准库函数, new/delete 是 C++ 的操作符.
    - malloc/free 只分配、释放内存, new/delete 还可以用来创建、释放对象,会自动执行对象的构造函数和析构函数.
    - new/delete 的写法比 malloc/free 简洁,如 
      ```
      int* p = new int;
      int* p = (int*) malloc(sizeof(int));
      ```
    - new/delete 在创建数组时,特别注意 int* p = new int[100]; 在释放时也要加上[], delete [] p;
      当我们 new 的是一个对象数组时, delete 时没有加上 [], 则数组中其他对象的析构函数不会被调用(存在一种误解,
      delete 没加上[]则只会释放第一个对象的内存,然后剩余的99个对象的内存没有被释放).

  ## 1.3 堆和栈的区别

  栈空间是调用函数时系统自动分配的一块有限的空间,使用栈空间并不需要程序员分配内存,这些都是系统自动分配的,栈也会
  自动释放对象.在函数中,传入参数或者定义一个局部变量,都是存放在栈空间上的.
  
  堆空间是程序在运行中可以动态分配、回收的一块足够大的空间,只要用 new 或 malloc, 就可以在对上分配空间.
    - 栈是程序启动时分配的一块内存,程序结束时释放,栈上的对象会在函数结束时被自动释放,程序员无法控制.而堆时程序
      运行时程序员手动创建的内存,手动释放,程序结束时会自动释放未释放的堆内存.由程序员手动管理的堆内存容易出现
      内存泄漏.
    - 栈是一块有限的内存空间,当超出容量时,就会出现栈溢出,Linux下默认的栈空间为 10MB, Windows 下默认的栈空间为
      1MB, 这个大小可以被修改.堆是一块足够大的内存空间.
    - 栈空间的分配是由系统执行的,有专门的指令来操作,根据所需内存的大小直接取出可用内存,因为栈的内存是连续的,所以
      并不需要查找内存,非常高效.而堆空间的分配,代价就比较大了,首先会在堆内存中搜索可用的内存块,如果找不到则从用户
      态切换到内核态,请求操作系统分配内存.因为堆空间并不是连续的,所以反复地分配和释放后,很容易产生内存碎片.
    堆和栈的取舍: 
    - 需要更好地控制对象的生命周期,则必须用堆;
    - 需要分配大块的内存,或者要分配的内存大小是连续的,也倾向用堆;
    - 其他情况下尽量用栈,以保证安全高效,无内存碎片及内存泄漏.

  ## 1.4 代码分析

  下面通过一些代码来加深了解
    ```
    // 在函数 fun 下执行,在栈空间分配了4个字节的内存来放指针 p
    // 在堆空间中分配了 4*100 字节的内存来存放动态数组的实际内容
    // 通过指针 p 可以操作指针指向的堆内存
    int* p = new int[100];

    // 程序启动时在静态存储区分配来4个字节的内存来存放指针 p
    // 程序运行到该代码时在堆内存分配了 4*100 字节的内存来存放动态数组的实际内容
    // 通过指针 p 可以操作指针指向的堆内存
    static int* p = new int[100];
    ```    

  更多知识,如多线程、动态链接库的内存细节

# 2.内存泄漏、野指针和跨动态链接库的内存使用
  ## 2.1 内存泄漏
    - 函数中新建了一块内存或一个对象,return前忘记释放.
      => 使用栈空间来创建这个对象,可以有效避免这个问题
    - 在一个函数中分配了堆内存,但外部有大量的地方引用到了这块内存,结果没有删除这块内存,导致内存泄漏.
      => 使用内存分配原则:谁分配谁释放,或者引用计数.

    如何定位: 
    - 如果怀疑某个对象是否存在内存泄漏,可以简单地在它的构造函数和析构函数对一个静态变量进行计数,
    如果在确保不使用它们的情况下,该静态变量不为0,说明有对象分配了而没有释放,存在内存泄漏
    - 通过重载全局的 new 和 delete 操作符也是检测内存泄漏的思路

  ## 2.2 野指针
  常见的野指针错误及解决方案
    - 释放了一个指针,没有手动将其设置为 NULL,再次使用这个指针而导致崩溃
    => 做到释放后置为 NULL,使用前检查,养成良好习惯就可以避免
    - 引用的地方太多,导致释放了还在使用的指针
    => 查找该指针所有的引用,找到谁释放的它,然后通过log或者断点调试来定位问题
    => 引用计数可以很好的避免野指针的问题.

  ## 2.3 动态链接库的内存
  在 Windows 中释放从 Dll 中创建的内存会导致崩溃,而 Linux 则可以正常运行.这实际上是两者的堆实现不同导致的.
  
  Windows 允许一个进程内,存在多个堆,在一个堆中分配的内存在其他堆中释放,这是跨动态链接库释放内存崩溃的根本原因.
  在 Windows 下动态链接库和应用程序默认不是使用同一个堆.
  将C++运行库设置为多线程调试 DLL(/MDd) 或多线程 DLL(/MD) 可以避开这个为题.
  Cocos2d-x 默认是这么设置的.
  
  Linux 的进程只有一个堆,所有堆内存分配和释放都是在这个对上进行操作,所以运行正常.


# 3.Cocos2d-x 的引用计数
引用计数很好的解决了内存泄漏和野指针的问题,在 Cocos2d-x 中,实现了引用计数,是非常简洁清晰的实现,其使用非常简单,
只包含了3个函数 retain、release 和 autorelease, autorelease 是基于引用计数而增加的自动释放功能.

在 Cocos2d-x 3.0 之前的版本中,引用计数的功能是放在 CCObject 的类中, 在 Cocos2d-x 3.0 之后,引用计数的功能被
封装在 Ref 类中. 新的 Ref 中自带了内存泄漏检测功能, 开启 CC_USE_MEM_LEAK_DETECTION 宏即可使用内存泄漏检测,
其实现与2节所说的内存泄漏检查方式类似,通过对构造函数和析构函数的处理,来检测内存泄漏.

实际上,只要用好 retain 和 release, 基本上可以避免 Ref 对象的内存泄漏.
  - 构造函数中,引用计数成员变量被设置为 1
  - 当调用 retain 时,引用计数自增 1
  - 当调用 release 时,引用计数自减 1, 并判断引用计数是否为 0, 如果是则执行 delete this 操作
  - 当调用 autorelease 时,引用计数自增1, 并在切换到下一帧时自动减 1

# 4.容器对象的内存管理
Cocos2d-x 常用的容器有 CCArray、CCSet 和 CCDictionary 这3种,分别是数组、集合和字典,从3.0开始,它们被替换为
Vector、Set 和 Map, 统一使用 C++ 标准库的容器
  - CCArray/Vector
    - 优点: 遍历操作高效,使用下标进行随机访问高效,连续的内存, push_back 操作高效;
    - 缺点: 在内部进行插入和删除效率低,插入的内容超出容量大小时,会产生重新分配、复制、释放等消耗
  
  - CCDictionary/Map 是一种 key-value 的关联容器
    - 优点: 查找效率高,插入删除也相对高效
    - 缺点: 不适合存储非键值对的对象.

    STL 的 Map 使用红黑树实现,默认是按照 Key 的大小自动排序,无法按照自定义的规则进行排序

  - CCSet/Set 是 CCObject 的集合,实际上只是对 STL 的 set 进行了一下简单的封装,主要增加了对容器内元素的 retain
    和 release 的调用,在内存的管理上,同 CCDictionary/Map一致
    - 优点: 查找效率高,插入删除也相对高效,并且可以快速得到两个 set 之间的交集、并集、差集
    - 缺点: 插入和删除的效率低于 list, 遍历的效率低于 vector.

  Cocos2d-x 对象内存的管理非常简单,只是保证在保存的时候执行 retain 操作,删除的时候执行 release 操作.
  
  除了 vector、map、set,常用的还有 list、queue 和 stack 等容器.

# 5.复制对象

# 6.内存优化